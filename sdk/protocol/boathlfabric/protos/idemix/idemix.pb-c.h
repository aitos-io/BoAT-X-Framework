/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: idemix/idemix.proto */

#ifndef PROTOBUF_C_idemix_2fidemix_2eproto__INCLUDED
#define PROTOBUF_C_idemix_2fidemix_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1000000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1002001 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif


typedef struct _ECP ECP;
typedef struct _ECP2 ECP2;
typedef struct _IssuerPublicKey IssuerPublicKey;
typedef struct _IssuerKey IssuerKey;
typedef struct _Credential Credential;
typedef struct _CredRequest CredRequest;
typedef struct _Signature Signature;
typedef struct _NonRevocationProof NonRevocationProof;
typedef struct _NymSignature NymSignature;
typedef struct _CredentialRevocationInformation CredentialRevocationInformation;


/* --- enums --- */


/* --- messages --- */

/*
 * ECP is an elliptic curve point specified by its coordinates
 * ECP corresponds to an element of the first group (G1)
 */
struct  _ECP
{
  ProtobufCMessage base;
  protobuf_c_boolean has_x;
  ProtobufCBinaryData x;
  protobuf_c_boolean has_y;
  ProtobufCBinaryData y;
};
#define ECP__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&ecp__descriptor) \
    , 0,{0,NULL}, 0,{0,NULL} }


/*
 * ECP2 is an elliptic curve point specified by its coordinates
 * ECP2 corresponds to an element of the second group (G2)
 */
struct  _ECP2
{
  ProtobufCMessage base;
  protobuf_c_boolean has_xa;
  ProtobufCBinaryData xa;
  protobuf_c_boolean has_xb;
  ProtobufCBinaryData xb;
  protobuf_c_boolean has_ya;
  ProtobufCBinaryData ya;
  protobuf_c_boolean has_yb;
  ProtobufCBinaryData yb;
};
#define ECP2__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&ecp2__descriptor) \
    , 0,{0,NULL}, 0,{0,NULL}, 0,{0,NULL}, 0,{0,NULL} }


/*
 * IssuerPublicKey specifies an issuer public key that consists of
 * attribute_names - a list of the attribute names of a credential issued by the issuer
 * h_sk, h_rand, h_attrs, w, bar_g1, bar_g2 - group elements corresponding to the signing key, randomness, and attributes
 * proof_c, proof_s compose a zero-knowledge proof of knowledge of the secret key
 * hash is a hash of the public key appended to it
 */
struct  _IssuerPublicKey
{
  ProtobufCMessage base;
  size_t n_attribute_names;
  char **attribute_names;
  ECP *h_sk;
  ECP *h_rand;
  size_t n_h_attrs;
  ECP **h_attrs;
  ECP2 *w;
  ECP *bar_g1;
  ECP *bar_g2;
  protobuf_c_boolean has_proof_c;
  ProtobufCBinaryData proof_c;
  protobuf_c_boolean has_proof_s;
  ProtobufCBinaryData proof_s;
  protobuf_c_boolean has_hash;
  ProtobufCBinaryData hash;
};
#define ISSUER_PUBLIC_KEY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&issuer_public_key__descriptor) \
    , 0,NULL, NULL, NULL, 0,NULL, NULL, NULL, NULL, 0,{0,NULL}, 0,{0,NULL}, 0,{0,NULL} }


/*
 * IssuerKey specifies an issuer key pair that consists of
 * ISk - the issuer secret key and
 * IssuerPublicKey - the issuer public key
 */
struct  _IssuerKey
{
  ProtobufCMessage base;
  protobuf_c_boolean has_isk;
  ProtobufCBinaryData isk;
  IssuerPublicKey *ipk;
};
#define ISSUER_KEY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&issuer_key__descriptor) \
    , 0,{0,NULL}, NULL }


/*
 * Credential specifies a credential object that consists of
 * a, b, e, s - signature value
 * attrs - attribute values
 */
struct  _Credential
{
  ProtobufCMessage base;
  ECP *a;
  ECP *b;
  protobuf_c_boolean has_e;
  ProtobufCBinaryData e;
  protobuf_c_boolean has_s;
  ProtobufCBinaryData s;
  size_t n_attrs;
  ProtobufCBinaryData *attrs;
};
#define CREDENTIAL__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&credential__descriptor) \
    , NULL, NULL, 0,{0,NULL}, 0,{0,NULL}, 0,NULL }


/*
 * CredRequest specifies a credential request object that consists of
 * nym - a pseudonym, which is a commitment to the user secret
 * issuer_nonce - a random nonce provided by the issuer
 * proof_c, proof_s - a zero-knowledge proof of knowledge of the
 * user secret inside Nym
 */
struct  _CredRequest
{
  ProtobufCMessage base;
  ECP *nym;
  protobuf_c_boolean has_issuer_nonce;
  ProtobufCBinaryData issuer_nonce;
  protobuf_c_boolean has_proof_c;
  ProtobufCBinaryData proof_c;
  protobuf_c_boolean has_proof_s;
  ProtobufCBinaryData proof_s;
};
#define CRED_REQUEST__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cred_request__descriptor) \
    , NULL, 0,{0,NULL}, 0,{0,NULL}, 0,{0,NULL} }


/*
 * Signature specifies a signature object that consists of
 * a_prime, a_bar, b_prime, proof_* - randomized credential signature values
 * and a zero-knowledge proof of knowledge of a credential
 * and the corresponding user secret together with the attribute values
 * nonce - a fresh nonce used for the signature
 * nym - a fresh pseudonym (a commitment to to the user secret)
 */
struct  _Signature
{
  ProtobufCMessage base;
  ECP *a_prime;
  ECP *a_bar;
  ECP *b_prime;
  protobuf_c_boolean has_proof_c;
  ProtobufCBinaryData proof_c;
  protobuf_c_boolean has_proof_s_sk;
  ProtobufCBinaryData proof_s_sk;
  protobuf_c_boolean has_proof_s_e;
  ProtobufCBinaryData proof_s_e;
  protobuf_c_boolean has_proof_s_r2;
  ProtobufCBinaryData proof_s_r2;
  protobuf_c_boolean has_proof_s_r3;
  ProtobufCBinaryData proof_s_r3;
  protobuf_c_boolean has_proof_s_s_prime;
  ProtobufCBinaryData proof_s_s_prime;
  size_t n_proof_s_attrs;
  ProtobufCBinaryData *proof_s_attrs;
  protobuf_c_boolean has_nonce;
  ProtobufCBinaryData nonce;
  ECP *nym;
  protobuf_c_boolean has_proof_s_r_nym;
  ProtobufCBinaryData proof_s_r_nym;
  ECP2 *revocation_epoch_pk;
  protobuf_c_boolean has_revocation_pk_sig;
  ProtobufCBinaryData revocation_pk_sig;
  protobuf_c_boolean has_epoch;
  int64_t epoch;
  NonRevocationProof *non_revocation_proof;
};
#define SIGNATURE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&signature__descriptor) \
    , NULL, NULL, NULL, 0,{0,NULL}, 0,{0,NULL}, 0,{0,NULL}, 0,{0,NULL}, 0,{0,NULL}, 0,{0,NULL}, 0,NULL, 0,{0,NULL}, NULL, 0,{0,NULL}, NULL, 0,{0,NULL}, 0,0, NULL }


/*
 * NonRevocationProof contains proof that the credential is not revoked
 */
struct  _NonRevocationProof
{
  ProtobufCMessage base;
  protobuf_c_boolean has_revocation_alg;
  int32_t revocation_alg;
  protobuf_c_boolean has_non_revocation_proof;
  ProtobufCBinaryData non_revocation_proof;
};
#define NON_REVOCATION_PROOF__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&non_revocation_proof__descriptor) \
    , 0,0, 0,{0,NULL} }


/*
 * NymSignature specifies a signature object that signs a message
 * with respect to a pseudonym. It differs from the standard idemix.signature in the fact that
 * the  standard signature object also proves that the pseudonym is based on a secret certified by
 * a CA (issuer), whereas NymSignature only proves that the the owner of the pseudonym
 * signed the message
 */
struct  _NymSignature
{
  ProtobufCMessage base;
  /*
   * proof_c is the Fiat-Shamir challenge of the ZKP
   */
  protobuf_c_boolean has_proof_c;
  ProtobufCBinaryData proof_c;
  /*
   * proof_s_sk is the s-value proving knowledge of the user secret key
   */
  protobuf_c_boolean has_proof_s_sk;
  ProtobufCBinaryData proof_s_sk;
  /*
   *proof_s_r_nym is the s-value proving knowledge of the pseudonym secret
   */
  protobuf_c_boolean has_proof_s_r_nym;
  ProtobufCBinaryData proof_s_r_nym;
  /*
   * nonce is a fresh nonce used for the signature
   */
  protobuf_c_boolean has_nonce;
  ProtobufCBinaryData nonce;
};
#define NYM_SIGNATURE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&nym_signature__descriptor) \
    , 0,{0,NULL}, 0,{0,NULL}, 0,{0,NULL}, 0,{0,NULL} }


struct  _CredentialRevocationInformation
{
  ProtobufCMessage base;
  /*
   * epoch contains the epoch (time window) in which this CRI is valid
   */
  protobuf_c_boolean has_epoch;
  int64_t epoch;
  /*
   * epoch_pk is the public key that is used by the revocation authority in this epoch
   */
  ECP2 *epoch_pk;
  /*
   * epoch_pk_sig is a signature on the EpochPK valid under the revocation authority's long term key
   */
  protobuf_c_boolean has_epoch_pk_sig;
  ProtobufCBinaryData epoch_pk_sig;
  /*
   * revocation_alg denotes which revocation algorithm is used
   */
  protobuf_c_boolean has_revocation_alg;
  int32_t revocation_alg;
  /*
   * revocation_data contains data specific to the revocation algorithm used
   */
  protobuf_c_boolean has_revocation_data;
  ProtobufCBinaryData revocation_data;
};
#define CREDENTIAL_REVOCATION_INFORMATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&credential_revocation_information__descriptor) \
    , 0,0, NULL, 0,{0,NULL}, 0,0, 0,{0,NULL} }


/* ECP methods */
void   ecp__init
                     (ECP         *message);
size_t ecp__get_packed_size
                     (const ECP   *message);
size_t ecp__pack
                     (const ECP   *message,
                      uint8_t             *out);
size_t ecp__pack_to_buffer
                     (const ECP   *message,
                      ProtobufCBuffer     *buffer);
ECP *
       ecp__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   ecp__free_unpacked
                     (ECP *message,
                      ProtobufCAllocator *allocator);
/* ECP2 methods */
void   ecp2__init
                     (ECP2         *message);
size_t ecp2__get_packed_size
                     (const ECP2   *message);
size_t ecp2__pack
                     (const ECP2   *message,
                      uint8_t             *out);
size_t ecp2__pack_to_buffer
                     (const ECP2   *message,
                      ProtobufCBuffer     *buffer);
ECP2 *
       ecp2__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   ecp2__free_unpacked
                     (ECP2 *message,
                      ProtobufCAllocator *allocator);
/* IssuerPublicKey methods */
void   issuer_public_key__init
                     (IssuerPublicKey         *message);
size_t issuer_public_key__get_packed_size
                     (const IssuerPublicKey   *message);
size_t issuer_public_key__pack
                     (const IssuerPublicKey   *message,
                      uint8_t             *out);
size_t issuer_public_key__pack_to_buffer
                     (const IssuerPublicKey   *message,
                      ProtobufCBuffer     *buffer);
IssuerPublicKey *
       issuer_public_key__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   issuer_public_key__free_unpacked
                     (IssuerPublicKey *message,
                      ProtobufCAllocator *allocator);
/* IssuerKey methods */
void   issuer_key__init
                     (IssuerKey         *message);
size_t issuer_key__get_packed_size
                     (const IssuerKey   *message);
size_t issuer_key__pack
                     (const IssuerKey   *message,
                      uint8_t             *out);
size_t issuer_key__pack_to_buffer
                     (const IssuerKey   *message,
                      ProtobufCBuffer     *buffer);
IssuerKey *
       issuer_key__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   issuer_key__free_unpacked
                     (IssuerKey *message,
                      ProtobufCAllocator *allocator);
/* Credential methods */
void   credential__init
                     (Credential         *message);
size_t credential__get_packed_size
                     (const Credential   *message);
size_t credential__pack
                     (const Credential   *message,
                      uint8_t             *out);
size_t credential__pack_to_buffer
                     (const Credential   *message,
                      ProtobufCBuffer     *buffer);
Credential *
       credential__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   credential__free_unpacked
                     (Credential *message,
                      ProtobufCAllocator *allocator);
/* CredRequest methods */
void   cred_request__init
                     (CredRequest         *message);
size_t cred_request__get_packed_size
                     (const CredRequest   *message);
size_t cred_request__pack
                     (const CredRequest   *message,
                      uint8_t             *out);
size_t cred_request__pack_to_buffer
                     (const CredRequest   *message,
                      ProtobufCBuffer     *buffer);
CredRequest *
       cred_request__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cred_request__free_unpacked
                     (CredRequest *message,
                      ProtobufCAllocator *allocator);
/* Signature methods */
void   signature__init
                     (Signature         *message);
size_t signature__get_packed_size
                     (const Signature   *message);
size_t signature__pack
                     (const Signature   *message,
                      uint8_t             *out);
size_t signature__pack_to_buffer
                     (const Signature   *message,
                      ProtobufCBuffer     *buffer);
Signature *
       signature__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   signature__free_unpacked
                     (Signature *message,
                      ProtobufCAllocator *allocator);
/* NonRevocationProof methods */
void   non_revocation_proof__init
                     (NonRevocationProof         *message);
size_t non_revocation_proof__get_packed_size
                     (const NonRevocationProof   *message);
size_t non_revocation_proof__pack
                     (const NonRevocationProof   *message,
                      uint8_t             *out);
size_t non_revocation_proof__pack_to_buffer
                     (const NonRevocationProof   *message,
                      ProtobufCBuffer     *buffer);
NonRevocationProof *
       non_revocation_proof__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   non_revocation_proof__free_unpacked
                     (NonRevocationProof *message,
                      ProtobufCAllocator *allocator);
/* NymSignature methods */
void   nym_signature__init
                     (NymSignature         *message);
size_t nym_signature__get_packed_size
                     (const NymSignature   *message);
size_t nym_signature__pack
                     (const NymSignature   *message,
                      uint8_t             *out);
size_t nym_signature__pack_to_buffer
                     (const NymSignature   *message,
                      ProtobufCBuffer     *buffer);
NymSignature *
       nym_signature__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   nym_signature__free_unpacked
                     (NymSignature *message,
                      ProtobufCAllocator *allocator);
/* CredentialRevocationInformation methods */
void   credential_revocation_information__init
                     (CredentialRevocationInformation         *message);
size_t credential_revocation_information__get_packed_size
                     (const CredentialRevocationInformation   *message);
size_t credential_revocation_information__pack
                     (const CredentialRevocationInformation   *message,
                      uint8_t             *out);
size_t credential_revocation_information__pack_to_buffer
                     (const CredentialRevocationInformation   *message,
                      ProtobufCBuffer     *buffer);
CredentialRevocationInformation *
       credential_revocation_information__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   credential_revocation_information__free_unpacked
                     (CredentialRevocationInformation *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*ECP_Closure)
                 (const ECP *message,
                  void *closure_data);
typedef void (*ECP2_Closure)
                 (const ECP2 *message,
                  void *closure_data);
typedef void (*IssuerPublicKey_Closure)
                 (const IssuerPublicKey *message,
                  void *closure_data);
typedef void (*IssuerKey_Closure)
                 (const IssuerKey *message,
                  void *closure_data);
typedef void (*Credential_Closure)
                 (const Credential *message,
                  void *closure_data);
typedef void (*CredRequest_Closure)
                 (const CredRequest *message,
                  void *closure_data);
typedef void (*Signature_Closure)
                 (const Signature *message,
                  void *closure_data);
typedef void (*NonRevocationProof_Closure)
                 (const NonRevocationProof *message,
                  void *closure_data);
typedef void (*NymSignature_Closure)
                 (const NymSignature *message,
                  void *closure_data);
typedef void (*CredentialRevocationInformation_Closure)
                 (const CredentialRevocationInformation *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCMessageDescriptor ecp__descriptor;
extern const ProtobufCMessageDescriptor ecp2__descriptor;
extern const ProtobufCMessageDescriptor issuer_public_key__descriptor;
extern const ProtobufCMessageDescriptor issuer_key__descriptor;
extern const ProtobufCMessageDescriptor credential__descriptor;
extern const ProtobufCMessageDescriptor cred_request__descriptor;
extern const ProtobufCMessageDescriptor signature__descriptor;
extern const ProtobufCMessageDescriptor non_revocation_proof__descriptor;
extern const ProtobufCMessageDescriptor nym_signature__descriptor;
extern const ProtobufCMessageDescriptor credential_revocation_information__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_idemix_2fidemix_2eproto__INCLUDED */
