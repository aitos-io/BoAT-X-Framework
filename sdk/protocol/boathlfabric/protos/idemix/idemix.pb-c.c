/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: idemix/idemix.proto */

/* Do not generate deprecated warnings for self */
#ifndef PROTOBUF_C__NO_DEPRECATED
#define PROTOBUF_C__NO_DEPRECATED
#endif

#include "idemix/idemix.pb-c.h"
void   ecp__init
                     (ECP         *message)
{
  static ECP init_value = ECP__INIT;
  *message = init_value;
}
size_t ecp__get_packed_size
                     (const ECP *message)
{
  assert(message->base.descriptor == &ecp__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t ecp__pack
                     (const ECP *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &ecp__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t ecp__pack_to_buffer
                     (const ECP *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &ecp__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
ECP *
       ecp__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (ECP *)
     protobuf_c_message_unpack (&ecp__descriptor,
                                allocator, len, data);
}
void   ecp__free_unpacked
                     (ECP *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &ecp__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   ecp2__init
                     (ECP2         *message)
{
  static ECP2 init_value = ECP2__INIT;
  *message = init_value;
}
size_t ecp2__get_packed_size
                     (const ECP2 *message)
{
  assert(message->base.descriptor == &ecp2__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t ecp2__pack
                     (const ECP2 *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &ecp2__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t ecp2__pack_to_buffer
                     (const ECP2 *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &ecp2__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
ECP2 *
       ecp2__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (ECP2 *)
     protobuf_c_message_unpack (&ecp2__descriptor,
                                allocator, len, data);
}
void   ecp2__free_unpacked
                     (ECP2 *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &ecp2__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   issuer_public_key__init
                     (IssuerPublicKey         *message)
{
  static IssuerPublicKey init_value = ISSUER_PUBLIC_KEY__INIT;
  *message = init_value;
}
size_t issuer_public_key__get_packed_size
                     (const IssuerPublicKey *message)
{
  assert(message->base.descriptor == &issuer_public_key__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t issuer_public_key__pack
                     (const IssuerPublicKey *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &issuer_public_key__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t issuer_public_key__pack_to_buffer
                     (const IssuerPublicKey *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &issuer_public_key__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
IssuerPublicKey *
       issuer_public_key__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (IssuerPublicKey *)
     protobuf_c_message_unpack (&issuer_public_key__descriptor,
                                allocator, len, data);
}
void   issuer_public_key__free_unpacked
                     (IssuerPublicKey *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &issuer_public_key__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   issuer_key__init
                     (IssuerKey         *message)
{
  static IssuerKey init_value = ISSUER_KEY__INIT;
  *message = init_value;
}
size_t issuer_key__get_packed_size
                     (const IssuerKey *message)
{
  assert(message->base.descriptor == &issuer_key__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t issuer_key__pack
                     (const IssuerKey *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &issuer_key__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t issuer_key__pack_to_buffer
                     (const IssuerKey *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &issuer_key__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
IssuerKey *
       issuer_key__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (IssuerKey *)
     protobuf_c_message_unpack (&issuer_key__descriptor,
                                allocator, len, data);
}
void   issuer_key__free_unpacked
                     (IssuerKey *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &issuer_key__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   credential__init
                     (Credential         *message)
{
  static Credential init_value = CREDENTIAL__INIT;
  *message = init_value;
}
size_t credential__get_packed_size
                     (const Credential *message)
{
  assert(message->base.descriptor == &credential__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t credential__pack
                     (const Credential *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &credential__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t credential__pack_to_buffer
                     (const Credential *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &credential__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Credential *
       credential__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Credential *)
     protobuf_c_message_unpack (&credential__descriptor,
                                allocator, len, data);
}
void   credential__free_unpacked
                     (Credential *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &credential__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   cred_request__init
                     (CredRequest         *message)
{
  static CredRequest init_value = CRED_REQUEST__INIT;
  *message = init_value;
}
size_t cred_request__get_packed_size
                     (const CredRequest *message)
{
  assert(message->base.descriptor == &cred_request__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t cred_request__pack
                     (const CredRequest *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &cred_request__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t cred_request__pack_to_buffer
                     (const CredRequest *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &cred_request__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
CredRequest *
       cred_request__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (CredRequest *)
     protobuf_c_message_unpack (&cred_request__descriptor,
                                allocator, len, data);
}
void   cred_request__free_unpacked
                     (CredRequest *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &cred_request__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   signature__init
                     (Signature         *message)
{
  static Signature init_value = SIGNATURE__INIT;
  *message = init_value;
}
size_t signature__get_packed_size
                     (const Signature *message)
{
  assert(message->base.descriptor == &signature__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t signature__pack
                     (const Signature *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &signature__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t signature__pack_to_buffer
                     (const Signature *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &signature__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Signature *
       signature__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Signature *)
     protobuf_c_message_unpack (&signature__descriptor,
                                allocator, len, data);
}
void   signature__free_unpacked
                     (Signature *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &signature__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   non_revocation_proof__init
                     (NonRevocationProof         *message)
{
  static NonRevocationProof init_value = NON_REVOCATION_PROOF__INIT;
  *message = init_value;
}
size_t non_revocation_proof__get_packed_size
                     (const NonRevocationProof *message)
{
  assert(message->base.descriptor == &non_revocation_proof__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t non_revocation_proof__pack
                     (const NonRevocationProof *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &non_revocation_proof__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t non_revocation_proof__pack_to_buffer
                     (const NonRevocationProof *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &non_revocation_proof__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
NonRevocationProof *
       non_revocation_proof__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (NonRevocationProof *)
     protobuf_c_message_unpack (&non_revocation_proof__descriptor,
                                allocator, len, data);
}
void   non_revocation_proof__free_unpacked
                     (NonRevocationProof *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &non_revocation_proof__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   nym_signature__init
                     (NymSignature         *message)
{
  static NymSignature init_value = NYM_SIGNATURE__INIT;
  *message = init_value;
}
size_t nym_signature__get_packed_size
                     (const NymSignature *message)
{
  assert(message->base.descriptor == &nym_signature__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t nym_signature__pack
                     (const NymSignature *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &nym_signature__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t nym_signature__pack_to_buffer
                     (const NymSignature *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &nym_signature__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
NymSignature *
       nym_signature__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (NymSignature *)
     protobuf_c_message_unpack (&nym_signature__descriptor,
                                allocator, len, data);
}
void   nym_signature__free_unpacked
                     (NymSignature *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &nym_signature__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   credential_revocation_information__init
                     (CredentialRevocationInformation         *message)
{
  static CredentialRevocationInformation init_value = CREDENTIAL_REVOCATION_INFORMATION__INIT;
  *message = init_value;
}
size_t credential_revocation_information__get_packed_size
                     (const CredentialRevocationInformation *message)
{
  assert(message->base.descriptor == &credential_revocation_information__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t credential_revocation_information__pack
                     (const CredentialRevocationInformation *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &credential_revocation_information__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t credential_revocation_information__pack_to_buffer
                     (const CredentialRevocationInformation *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &credential_revocation_information__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
CredentialRevocationInformation *
       credential_revocation_information__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (CredentialRevocationInformation *)
     protobuf_c_message_unpack (&credential_revocation_information__descriptor,
                                allocator, len, data);
}
void   credential_revocation_information__free_unpacked
                     (CredentialRevocationInformation *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &credential_revocation_information__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
static const ProtobufCFieldDescriptor ecp__field_descriptors[2] =
{
  {
    "x",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(ECP, has_x),
    offsetof(ECP, x),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "y",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(ECP, has_y),
    offsetof(ECP, y),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned ecp__field_indices_by_name[] = {
  0,   /* field[0] = x */
  1,   /* field[1] = y */
};
static const ProtobufCIntRange ecp__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor ecp__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "ECP",
  "ECP",
  "ECP",
  "",
  sizeof(ECP),
  2,
  ecp__field_descriptors,
  ecp__field_indices_by_name,
  1,  ecp__number_ranges,
  (ProtobufCMessageInit) ecp__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor ecp2__field_descriptors[4] =
{
  {
    "xa",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(ECP2, has_xa),
    offsetof(ECP2, xa),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "xb",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(ECP2, has_xb),
    offsetof(ECP2, xb),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "ya",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(ECP2, has_ya),
    offsetof(ECP2, ya),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "yb",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(ECP2, has_yb),
    offsetof(ECP2, yb),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned ecp2__field_indices_by_name[] = {
  0,   /* field[0] = xa */
  1,   /* field[1] = xb */
  2,   /* field[2] = ya */
  3,   /* field[3] = yb */
};
static const ProtobufCIntRange ecp2__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor ecp2__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "ECP2",
  "ECP2",
  "ECP2",
  "",
  sizeof(ECP2),
  4,
  ecp2__field_descriptors,
  ecp2__field_indices_by_name,
  1,  ecp2__number_ranges,
  (ProtobufCMessageInit) ecp2__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor issuer_public_key__field_descriptors[10] =
{
  {
    "attribute_names",
    1,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_STRING,
    offsetof(IssuerPublicKey, n_attribute_names),
    offsetof(IssuerPublicKey, attribute_names),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "h_sk",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(IssuerPublicKey, h_sk),
    &ecp__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "h_rand",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(IssuerPublicKey, h_rand),
    &ecp__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "h_attrs",
    4,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(IssuerPublicKey, n_h_attrs),
    offsetof(IssuerPublicKey, h_attrs),
    &ecp__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "w",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(IssuerPublicKey, w),
    &ecp2__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "bar_g1",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(IssuerPublicKey, bar_g1),
    &ecp__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "bar_g2",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(IssuerPublicKey, bar_g2),
    &ecp__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "proof_c",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(IssuerPublicKey, has_proof_c),
    offsetof(IssuerPublicKey, proof_c),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "proof_s",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(IssuerPublicKey, has_proof_s),
    offsetof(IssuerPublicKey, proof_s),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "hash",
    10,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(IssuerPublicKey, has_hash),
    offsetof(IssuerPublicKey, hash),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned issuer_public_key__field_indices_by_name[] = {
  0,   /* field[0] = attribute_names */
  5,   /* field[5] = bar_g1 */
  6,   /* field[6] = bar_g2 */
  3,   /* field[3] = h_attrs */
  2,   /* field[2] = h_rand */
  1,   /* field[1] = h_sk */
  9,   /* field[9] = hash */
  7,   /* field[7] = proof_c */
  8,   /* field[8] = proof_s */
  4,   /* field[4] = w */
};
static const ProtobufCIntRange issuer_public_key__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 10 }
};
const ProtobufCMessageDescriptor issuer_public_key__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "IssuerPublicKey",
  "IssuerPublicKey",
  "IssuerPublicKey",
  "",
  sizeof(IssuerPublicKey),
  10,
  issuer_public_key__field_descriptors,
  issuer_public_key__field_indices_by_name,
  1,  issuer_public_key__number_ranges,
  (ProtobufCMessageInit) issuer_public_key__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor issuer_key__field_descriptors[2] =
{
  {
    "isk",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(IssuerKey, has_isk),
    offsetof(IssuerKey, isk),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "ipk",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(IssuerKey, ipk),
    &issuer_public_key__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned issuer_key__field_indices_by_name[] = {
  1,   /* field[1] = ipk */
  0,   /* field[0] = isk */
};
static const ProtobufCIntRange issuer_key__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor issuer_key__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "IssuerKey",
  "IssuerKey",
  "IssuerKey",
  "",
  sizeof(IssuerKey),
  2,
  issuer_key__field_descriptors,
  issuer_key__field_indices_by_name,
  1,  issuer_key__number_ranges,
  (ProtobufCMessageInit) issuer_key__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor credential__field_descriptors[5] =
{
  {
    "a",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(Credential, a),
    &ecp__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "b",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(Credential, b),
    &ecp__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "e",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(Credential, has_e),
    offsetof(Credential, e),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "s",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(Credential, has_s),
    offsetof(Credential, s),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "attrs",
    5,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(Credential, n_attrs),
    offsetof(Credential, attrs),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned credential__field_indices_by_name[] = {
  0,   /* field[0] = a */
  4,   /* field[4] = attrs */
  1,   /* field[1] = b */
  2,   /* field[2] = e */
  3,   /* field[3] = s */
};
static const ProtobufCIntRange credential__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 5 }
};
const ProtobufCMessageDescriptor credential__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Credential",
  "Credential",
  "Credential",
  "",
  sizeof(Credential),
  5,
  credential__field_descriptors,
  credential__field_indices_by_name,
  1,  credential__number_ranges,
  (ProtobufCMessageInit) credential__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor cred_request__field_descriptors[4] =
{
  {
    "nym",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(CredRequest, nym),
    &ecp__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "issuer_nonce",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(CredRequest, has_issuer_nonce),
    offsetof(CredRequest, issuer_nonce),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "proof_c",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(CredRequest, has_proof_c),
    offsetof(CredRequest, proof_c),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "proof_s",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(CredRequest, has_proof_s),
    offsetof(CredRequest, proof_s),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned cred_request__field_indices_by_name[] = {
  1,   /* field[1] = issuer_nonce */
  0,   /* field[0] = nym */
  2,   /* field[2] = proof_c */
  3,   /* field[3] = proof_s */
};
static const ProtobufCIntRange cred_request__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor cred_request__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "CredRequest",
  "CredRequest",
  "CredRequest",
  "",
  sizeof(CredRequest),
  4,
  cred_request__field_descriptors,
  cred_request__field_indices_by_name,
  1,  cred_request__number_ranges,
  (ProtobufCMessageInit) cred_request__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor signature__field_descriptors[17] =
{
  {
    "a_prime",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(Signature, a_prime),
    &ecp__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "a_bar",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(Signature, a_bar),
    &ecp__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "b_prime",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(Signature, b_prime),
    &ecp__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "proof_c",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(Signature, has_proof_c),
    offsetof(Signature, proof_c),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "proof_s_sk",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(Signature, has_proof_s_sk),
    offsetof(Signature, proof_s_sk),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "proof_s_e",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(Signature, has_proof_s_e),
    offsetof(Signature, proof_s_e),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "proof_s_r2",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(Signature, has_proof_s_r2),
    offsetof(Signature, proof_s_r2),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "proof_s_r3",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(Signature, has_proof_s_r3),
    offsetof(Signature, proof_s_r3),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "proof_s_s_prime",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(Signature, has_proof_s_s_prime),
    offsetof(Signature, proof_s_s_prime),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "proof_s_attrs",
    10,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(Signature, n_proof_s_attrs),
    offsetof(Signature, proof_s_attrs),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "nonce",
    11,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(Signature, has_nonce),
    offsetof(Signature, nonce),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "nym",
    12,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(Signature, nym),
    &ecp__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "proof_s_r_nym",
    13,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(Signature, has_proof_s_r_nym),
    offsetof(Signature, proof_s_r_nym),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "revocation_epoch_pk",
    14,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(Signature, revocation_epoch_pk),
    &ecp2__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "revocation_pk_sig",
    15,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(Signature, has_revocation_pk_sig),
    offsetof(Signature, revocation_pk_sig),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "epoch",
    16,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_INT64,
    offsetof(Signature, has_epoch),
    offsetof(Signature, epoch),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "non_revocation_proof",
    17,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(Signature, non_revocation_proof),
    &non_revocation_proof__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned signature__field_indices_by_name[] = {
  1,   /* field[1] = a_bar */
  0,   /* field[0] = a_prime */
  2,   /* field[2] = b_prime */
  15,   /* field[15] = epoch */
  16,   /* field[16] = non_revocation_proof */
  10,   /* field[10] = nonce */
  11,   /* field[11] = nym */
  3,   /* field[3] = proof_c */
  9,   /* field[9] = proof_s_attrs */
  5,   /* field[5] = proof_s_e */
  6,   /* field[6] = proof_s_r2 */
  7,   /* field[7] = proof_s_r3 */
  12,   /* field[12] = proof_s_r_nym */
  8,   /* field[8] = proof_s_s_prime */
  4,   /* field[4] = proof_s_sk */
  13,   /* field[13] = revocation_epoch_pk */
  14,   /* field[14] = revocation_pk_sig */
};
static const ProtobufCIntRange signature__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 17 }
};
const ProtobufCMessageDescriptor signature__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Signature",
  "Signature",
  "Signature",
  "",
  sizeof(Signature),
  17,
  signature__field_descriptors,
  signature__field_indices_by_name,
  1,  signature__number_ranges,
  (ProtobufCMessageInit) signature__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor non_revocation_proof__field_descriptors[2] =
{
  {
    "revocation_alg",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_INT32,
    offsetof(NonRevocationProof, has_revocation_alg),
    offsetof(NonRevocationProof, revocation_alg),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "non_revocation_proof",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(NonRevocationProof, has_non_revocation_proof),
    offsetof(NonRevocationProof, non_revocation_proof),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned non_revocation_proof__field_indices_by_name[] = {
  1,   /* field[1] = non_revocation_proof */
  0,   /* field[0] = revocation_alg */
};
static const ProtobufCIntRange non_revocation_proof__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor non_revocation_proof__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "NonRevocationProof",
  "NonRevocationProof",
  "NonRevocationProof",
  "",
  sizeof(NonRevocationProof),
  2,
  non_revocation_proof__field_descriptors,
  non_revocation_proof__field_indices_by_name,
  1,  non_revocation_proof__number_ranges,
  (ProtobufCMessageInit) non_revocation_proof__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor nym_signature__field_descriptors[4] =
{
  {
    "proof_c",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(NymSignature, has_proof_c),
    offsetof(NymSignature, proof_c),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "proof_s_sk",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(NymSignature, has_proof_s_sk),
    offsetof(NymSignature, proof_s_sk),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "proof_s_r_nym",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(NymSignature, has_proof_s_r_nym),
    offsetof(NymSignature, proof_s_r_nym),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "nonce",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(NymSignature, has_nonce),
    offsetof(NymSignature, nonce),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned nym_signature__field_indices_by_name[] = {
  3,   /* field[3] = nonce */
  0,   /* field[0] = proof_c */
  2,   /* field[2] = proof_s_r_nym */
  1,   /* field[1] = proof_s_sk */
};
static const ProtobufCIntRange nym_signature__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor nym_signature__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "NymSignature",
  "NymSignature",
  "NymSignature",
  "",
  sizeof(NymSignature),
  4,
  nym_signature__field_descriptors,
  nym_signature__field_indices_by_name,
  1,  nym_signature__number_ranges,
  (ProtobufCMessageInit) nym_signature__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor credential_revocation_information__field_descriptors[5] =
{
  {
    "epoch",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_INT64,
    offsetof(CredentialRevocationInformation, has_epoch),
    offsetof(CredentialRevocationInformation, epoch),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "epoch_pk",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(CredentialRevocationInformation, epoch_pk),
    &ecp2__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "epoch_pk_sig",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(CredentialRevocationInformation, has_epoch_pk_sig),
    offsetof(CredentialRevocationInformation, epoch_pk_sig),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "revocation_alg",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_INT32,
    offsetof(CredentialRevocationInformation, has_revocation_alg),
    offsetof(CredentialRevocationInformation, revocation_alg),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "revocation_data",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(CredentialRevocationInformation, has_revocation_data),
    offsetof(CredentialRevocationInformation, revocation_data),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned credential_revocation_information__field_indices_by_name[] = {
  0,   /* field[0] = epoch */
  1,   /* field[1] = epoch_pk */
  2,   /* field[2] = epoch_pk_sig */
  3,   /* field[3] = revocation_alg */
  4,   /* field[4] = revocation_data */
};
static const ProtobufCIntRange credential_revocation_information__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 5 }
};
const ProtobufCMessageDescriptor credential_revocation_information__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "CredentialRevocationInformation",
  "CredentialRevocationInformation",
  "CredentialRevocationInformation",
  "",
  sizeof(CredentialRevocationInformation),
  5,
  credential_revocation_information__field_descriptors,
  credential_revocation_information__field_indices_by_name,
  1,  credential_revocation_information__number_ranges,
  (ProtobufCMessageInit) credential_revocation_information__init,
  NULL,NULL,NULL    /* reserved[123] */
};
