/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: common/policies.proto */

#ifndef PROTOBUF_C_common_2fpolicies_2eproto__INCLUDED
#define PROTOBUF_C_common_2fpolicies_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1000000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1002001 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif

#include "msp/msp_principal.pb-c.h"

typedef struct _Common__Policy Common__Policy;
typedef struct _Common__SignaturePolicyEnvelope Common__SignaturePolicyEnvelope;
typedef struct _Common__SignaturePolicy Common__SignaturePolicy;
typedef struct _Common__SignaturePolicy__NOutOf Common__SignaturePolicy__NOutOf;
typedef struct _Common__ImplicitMetaPolicy Common__ImplicitMetaPolicy;


/* --- enums --- */

typedef enum _Common__Policy__PolicyType {
  /*
   * Reserved to check for proper initialization
   */
  COMMON__POLICY__POLICY_TYPE__UNKNOWN = 0,
  COMMON__POLICY__POLICY_TYPE__SIGNATURE = 1,
  COMMON__POLICY__POLICY_TYPE__MSP = 2,
  COMMON__POLICY__POLICY_TYPE__IMPLICIT_META = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(COMMON__POLICY__POLICY_TYPE)
} Common__Policy__PolicyType;
typedef enum _Common__ImplicitMetaPolicy__Rule {
  /*
   * Requires any of the sub-policies be satisfied, if no sub-policies exist, always returns true
   */
  COMMON__IMPLICIT_META_POLICY__RULE__ANY = 0,
  /*
   * Requires all of the sub-policies be satisfied
   */
  COMMON__IMPLICIT_META_POLICY__RULE__ALL = 1,
  /*
   * Requires a strict majority (greater than half) of the sub-policies be satisfied
   */
  COMMON__IMPLICIT_META_POLICY__RULE__MAJORITY = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(COMMON__IMPLICIT_META_POLICY__RULE)
} Common__ImplicitMetaPolicy__Rule;

/* --- messages --- */

/*
 * Policy expresses a policy which the orderer can evaluate, because there has been some desire expressed to support
 * multiple policy engines, this is typed as a oneof for now
 */
struct  _Common__Policy
{
  ProtobufCMessage base;
  /*
   * For outside implementors, consider the first 1000 types reserved, otherwise one of PolicyType
   */
  protobuf_c_boolean has_type;
  int32_t type;
  protobuf_c_boolean has_value;
  ProtobufCBinaryData value;
};
#define COMMON__POLICY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&common__policy__descriptor) \
    , 0,0, 0,{0,NULL} }


/*
 * SignaturePolicyEnvelope wraps a SignaturePolicy and includes a version for future enhancements
 */
struct  _Common__SignaturePolicyEnvelope
{
  ProtobufCMessage base;
  protobuf_c_boolean has_version;
  int32_t version;
  Common__SignaturePolicy *rule;
  size_t n_identities;
  Common__MSPPrincipal **identities;
};
#define COMMON__SIGNATURE_POLICY_ENVELOPE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&common__signature_policy_envelope__descriptor) \
    , 0,0, NULL, 0,NULL }


struct  _Common__SignaturePolicy__NOutOf
{
  ProtobufCMessage base;
  protobuf_c_boolean has_n;
  int32_t n;
  size_t n_rules;
  Common__SignaturePolicy **rules;
};
#define COMMON__SIGNATURE_POLICY__NOUT_OF__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&common__signature_policy__nout_of__descriptor) \
    , 0,0, 0,NULL }


typedef enum {
  COMMON__SIGNATURE_POLICY__TYPE__NOT_SET = 0,
  COMMON__SIGNATURE_POLICY__TYPE_SIGNED_BY = 1,
  COMMON__SIGNATURE_POLICY__TYPE_N_OUT_OF = 2,
} Common__SignaturePolicy__TypeCase;

/*
 * SignaturePolicy is a recursive message structure which defines a featherweight DSL for describing
 * policies which are more complicated than 'exactly this signature'.  The NOutOf operator is sufficent
 * to express AND as well as OR, as well as of course N out of the following M policies
 * SignedBy implies that the signature is from a valid certificate which is signed by the trusted
 * authority specified in the bytes.  This will be the certificate itself for a self-signed certificate
 * and will be the CA for more traditional certificates
 */
struct  _Common__SignaturePolicy
{
  ProtobufCMessage base;
  Common__SignaturePolicy__TypeCase type_case;
  union {
    int32_t signed_by;
    Common__SignaturePolicy__NOutOf *n_out_of;
  };
};
#define COMMON__SIGNATURE_POLICY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&common__signature_policy__descriptor) \
    , COMMON__SIGNATURE_POLICY__TYPE__NOT_SET, {0} }


/*
 * ImplicitMetaPolicy is a policy type which depends on the hierarchical nature of the configuration
 * It is implicit because the rule is generate implicitly based on the number of sub policies
 * It is meta because it depends only on the result of other policies
 * When evaluated, this policy iterates over all immediate child sub-groups, retrieves the policy
 * of name sub_policy, evaluates the collection and applies the rule.
 * For example, with 4 sub-groups, and a policy name of "foo", ImplicitMetaPolicy retrieves
 * each sub-group, retrieves policy "foo" for each subgroup, evaluates it, and, in the case of ANY
 * 1 satisfied is sufficient, ALL would require 4 signatures, and MAJORITY would require 3 signatures.
 */
struct  _Common__ImplicitMetaPolicy
{
  ProtobufCMessage base;
  char *sub_policy;
  protobuf_c_boolean has_rule;
  Common__ImplicitMetaPolicy__Rule rule;
};
#define COMMON__IMPLICIT_META_POLICY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&common__implicit_meta_policy__descriptor) \
    , NULL, 0,0 }


/* Common__Policy methods */
void   common__policy__init
                     (Common__Policy         *message);
size_t common__policy__get_packed_size
                     (const Common__Policy   *message);
size_t common__policy__pack
                     (const Common__Policy   *message,
                      uint8_t             *out);
size_t common__policy__pack_to_buffer
                     (const Common__Policy   *message,
                      ProtobufCBuffer     *buffer);
Common__Policy *
       common__policy__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   common__policy__free_unpacked
                     (Common__Policy *message,
                      ProtobufCAllocator *allocator);
/* Common__SignaturePolicyEnvelope methods */
void   common__signature_policy_envelope__init
                     (Common__SignaturePolicyEnvelope         *message);
size_t common__signature_policy_envelope__get_packed_size
                     (const Common__SignaturePolicyEnvelope   *message);
size_t common__signature_policy_envelope__pack
                     (const Common__SignaturePolicyEnvelope   *message,
                      uint8_t             *out);
size_t common__signature_policy_envelope__pack_to_buffer
                     (const Common__SignaturePolicyEnvelope   *message,
                      ProtobufCBuffer     *buffer);
Common__SignaturePolicyEnvelope *
       common__signature_policy_envelope__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   common__signature_policy_envelope__free_unpacked
                     (Common__SignaturePolicyEnvelope *message,
                      ProtobufCAllocator *allocator);
/* Common__SignaturePolicy__NOutOf methods */
void   common__signature_policy__nout_of__init
                     (Common__SignaturePolicy__NOutOf         *message);
/* Common__SignaturePolicy methods */
void   common__signature_policy__init
                     (Common__SignaturePolicy         *message);
size_t common__signature_policy__get_packed_size
                     (const Common__SignaturePolicy   *message);
size_t common__signature_policy__pack
                     (const Common__SignaturePolicy   *message,
                      uint8_t             *out);
size_t common__signature_policy__pack_to_buffer
                     (const Common__SignaturePolicy   *message,
                      ProtobufCBuffer     *buffer);
Common__SignaturePolicy *
       common__signature_policy__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   common__signature_policy__free_unpacked
                     (Common__SignaturePolicy *message,
                      ProtobufCAllocator *allocator);
/* Common__ImplicitMetaPolicy methods */
void   common__implicit_meta_policy__init
                     (Common__ImplicitMetaPolicy         *message);
size_t common__implicit_meta_policy__get_packed_size
                     (const Common__ImplicitMetaPolicy   *message);
size_t common__implicit_meta_policy__pack
                     (const Common__ImplicitMetaPolicy   *message,
                      uint8_t             *out);
size_t common__implicit_meta_policy__pack_to_buffer
                     (const Common__ImplicitMetaPolicy   *message,
                      ProtobufCBuffer     *buffer);
Common__ImplicitMetaPolicy *
       common__implicit_meta_policy__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   common__implicit_meta_policy__free_unpacked
                     (Common__ImplicitMetaPolicy *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*Common__Policy_Closure)
                 (const Common__Policy *message,
                  void *closure_data);
typedef void (*Common__SignaturePolicyEnvelope_Closure)
                 (const Common__SignaturePolicyEnvelope *message,
                  void *closure_data);
typedef void (*Common__SignaturePolicy__NOutOf_Closure)
                 (const Common__SignaturePolicy__NOutOf *message,
                  void *closure_data);
typedef void (*Common__SignaturePolicy_Closure)
                 (const Common__SignaturePolicy *message,
                  void *closure_data);
typedef void (*Common__ImplicitMetaPolicy_Closure)
                 (const Common__ImplicitMetaPolicy *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCMessageDescriptor common__policy__descriptor;
extern const ProtobufCEnumDescriptor    common__policy__policy_type__descriptor;
extern const ProtobufCMessageDescriptor common__signature_policy_envelope__descriptor;
extern const ProtobufCMessageDescriptor common__signature_policy__descriptor;
extern const ProtobufCMessageDescriptor common__signature_policy__nout_of__descriptor;
extern const ProtobufCMessageDescriptor common__implicit_meta_policy__descriptor;
extern const ProtobufCEnumDescriptor    common__implicit_meta_policy__rule__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_common_2fpolicies_2eproto__INCLUDED */
