/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: common/configuration.proto */

#ifndef PROTOBUF_C_common_2fconfiguration_2eproto__INCLUDED
#define PROTOBUF_C_common_2fconfiguration_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1000000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1002001 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif


typedef struct _Common__HashingAlgorithm Common__HashingAlgorithm;
typedef struct _Common__BlockDataHashingStructure Common__BlockDataHashingStructure;
typedef struct _Common__OrdererAddresses Common__OrdererAddresses;
typedef struct _Common__Consortium Common__Consortium;
typedef struct _Common__Capabilities Common__Capabilities;
typedef struct _Common__Capabilities__CapabilitiesEntry Common__Capabilities__CapabilitiesEntry;
typedef struct _Common__Capability Common__Capability;


/* --- enums --- */


/* --- messages --- */

/*
 * HashingAlgorithm is encoded into the configuration transaction as  a configuration item of type Chain
 * with a Key of "HashingAlgorithm" and a Value of  HashingAlgorithm as marshaled protobuf bytes
 */
struct  _Common__HashingAlgorithm
{
  ProtobufCMessage base;
  /*
   * Currently supported algorithms are: SHAKE256
   */
  char *name;
};
#define COMMON__HASHING_ALGORITHM__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&common__hashing_algorithm__descriptor) \
    , NULL }


/*
 * BlockDataHashingStructure is encoded into the configuration transaction as a configuration item of
 * type Chain with a Key of "BlockDataHashingStructure" and a Value of HashingAlgorithm as marshaled protobuf bytes
 */
struct  _Common__BlockDataHashingStructure
{
  ProtobufCMessage base;
  /*
   * width specifies the width of the Merkle tree to use when computing the BlockDataHash
   * in order to replicate flat hashing, set this width to MAX_UINT32
   */
  protobuf_c_boolean has_width;
  uint32_t width;
};
#define COMMON__BLOCK_DATA_HASHING_STRUCTURE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&common__block_data_hashing_structure__descriptor) \
    , 0,0 }


/*
 * OrdererAddresses is encoded into the configuration transaction as a configuration item of type Chain
 * with a Key of "OrdererAddresses" and a Value of OrdererAddresses as marshaled protobuf bytes
 */
struct  _Common__OrdererAddresses
{
  ProtobufCMessage base;
  size_t n_addresses;
  char **addresses;
};
#define COMMON__ORDERER_ADDRESSES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&common__orderer_addresses__descriptor) \
    , 0,NULL }


/*
 * Consortium represents the consortium context in which the channel was created
 */
struct  _Common__Consortium
{
  ProtobufCMessage base;
  char *name;
};
#define COMMON__CONSORTIUM__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&common__consortium__descriptor) \
    , NULL }


struct  _Common__Capabilities__CapabilitiesEntry
{
  ProtobufCMessage base;
  char *key;
  Common__Capability *value;
};
#define COMMON__CAPABILITIES__CAPABILITIES_ENTRY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&common__capabilities__capabilities_entry__descriptor) \
    , NULL, NULL }


/*
 * Capabilities message defines the capabilities a particular binary must implement
 * for that binary to be able to safely participate in the channel.  The capabilities
 * message is defined at the /Channel level, the /Channel/Application level, and the
 * /Channel/Orderer level.
 * The /Channel level capabilties define capabilities which both the orderer and peer
 * binaries must satisfy.  These capabilties might be things like a new MSP type,
 * or a new policy type.
 * The /Channel/Orderer level capabilties define capabilities which must be supported
 * by the orderer, but which have no bearing on the behavior of the peer.  For instance
 * if the orderer changes the logic for how it constructs new channels, only all orderers
 * must agree on the new logic.  The peers do not need to be aware of this change as
 * they only interact with the channel after it has been constructed.
 * Finally, the /Channel/Application level capabilities define capabilities which the peer
 * binary must satisfy, but which have no bearing on the orderer.  For instance, if the
 * peer adds a new UTXO transaction type, or changes the chaincode lifecycle requirements,
 * all peers must agree on the new logic.  However, orderers never inspect transactions
 * this deeply, and therefore have no need to be aware of the change.
 * The capabilities strings defined in these messages typically correspond to release
 * binary versions (e.g. "V1.1"), and are used primarilly as a mechanism for a fully
 * upgraded network to switch from one set of logic to a new one.
 * Although for V1.1, the orderers must be upgraded to V1.1 prior to the rest of the
 * network, going forward, because of the split between the /Channel, /Channel/Orderer
 * and /Channel/Application capabilities.  It should be possible for the orderer and
 * application networks to upgrade themselves independently (with the exception of any
 * new capabilities defined at the /Channel level).
 */
struct  _Common__Capabilities
{
  ProtobufCMessage base;
  size_t n_capabilities;
  Common__Capabilities__CapabilitiesEntry **capabilities;
};
#define COMMON__CAPABILITIES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&common__capabilities__descriptor) \
    , 0,NULL }


/*
 * Capability is an empty message for the time being.  It is defined as a protobuf
 * message rather than a constant, so that we may extend capabilities with other fields
 * if the need arises in the future.  For the time being, a capability being in the
 * capabilities map requires that that capability be supported.
 */
struct  _Common__Capability
{
  ProtobufCMessage base;
};
#define COMMON__CAPABILITY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&common__capability__descriptor) \
     }


/* Common__HashingAlgorithm methods */
void   common__hashing_algorithm__init
                     (Common__HashingAlgorithm         *message);
size_t common__hashing_algorithm__get_packed_size
                     (const Common__HashingAlgorithm   *message);
size_t common__hashing_algorithm__pack
                     (const Common__HashingAlgorithm   *message,
                      uint8_t             *out);
size_t common__hashing_algorithm__pack_to_buffer
                     (const Common__HashingAlgorithm   *message,
                      ProtobufCBuffer     *buffer);
Common__HashingAlgorithm *
       common__hashing_algorithm__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   common__hashing_algorithm__free_unpacked
                     (Common__HashingAlgorithm *message,
                      ProtobufCAllocator *allocator);
/* Common__BlockDataHashingStructure methods */
void   common__block_data_hashing_structure__init
                     (Common__BlockDataHashingStructure         *message);
size_t common__block_data_hashing_structure__get_packed_size
                     (const Common__BlockDataHashingStructure   *message);
size_t common__block_data_hashing_structure__pack
                     (const Common__BlockDataHashingStructure   *message,
                      uint8_t             *out);
size_t common__block_data_hashing_structure__pack_to_buffer
                     (const Common__BlockDataHashingStructure   *message,
                      ProtobufCBuffer     *buffer);
Common__BlockDataHashingStructure *
       common__block_data_hashing_structure__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   common__block_data_hashing_structure__free_unpacked
                     (Common__BlockDataHashingStructure *message,
                      ProtobufCAllocator *allocator);
/* Common__OrdererAddresses methods */
void   common__orderer_addresses__init
                     (Common__OrdererAddresses         *message);
size_t common__orderer_addresses__get_packed_size
                     (const Common__OrdererAddresses   *message);
size_t common__orderer_addresses__pack
                     (const Common__OrdererAddresses   *message,
                      uint8_t             *out);
size_t common__orderer_addresses__pack_to_buffer
                     (const Common__OrdererAddresses   *message,
                      ProtobufCBuffer     *buffer);
Common__OrdererAddresses *
       common__orderer_addresses__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   common__orderer_addresses__free_unpacked
                     (Common__OrdererAddresses *message,
                      ProtobufCAllocator *allocator);
/* Common__Consortium methods */
void   common__consortium__init
                     (Common__Consortium         *message);
size_t common__consortium__get_packed_size
                     (const Common__Consortium   *message);
size_t common__consortium__pack
                     (const Common__Consortium   *message,
                      uint8_t             *out);
size_t common__consortium__pack_to_buffer
                     (const Common__Consortium   *message,
                      ProtobufCBuffer     *buffer);
Common__Consortium *
       common__consortium__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   common__consortium__free_unpacked
                     (Common__Consortium *message,
                      ProtobufCAllocator *allocator);
/* Common__Capabilities__CapabilitiesEntry methods */
void   common__capabilities__capabilities_entry__init
                     (Common__Capabilities__CapabilitiesEntry         *message);
/* Common__Capabilities methods */
void   common__capabilities__init
                     (Common__Capabilities         *message);
size_t common__capabilities__get_packed_size
                     (const Common__Capabilities   *message);
size_t common__capabilities__pack
                     (const Common__Capabilities   *message,
                      uint8_t             *out);
size_t common__capabilities__pack_to_buffer
                     (const Common__Capabilities   *message,
                      ProtobufCBuffer     *buffer);
Common__Capabilities *
       common__capabilities__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   common__capabilities__free_unpacked
                     (Common__Capabilities *message,
                      ProtobufCAllocator *allocator);
/* Common__Capability methods */
void   common__capability__init
                     (Common__Capability         *message);
size_t common__capability__get_packed_size
                     (const Common__Capability   *message);
size_t common__capability__pack
                     (const Common__Capability   *message,
                      uint8_t             *out);
size_t common__capability__pack_to_buffer
                     (const Common__Capability   *message,
                      ProtobufCBuffer     *buffer);
Common__Capability *
       common__capability__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   common__capability__free_unpacked
                     (Common__Capability *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*Common__HashingAlgorithm_Closure)
                 (const Common__HashingAlgorithm *message,
                  void *closure_data);
typedef void (*Common__BlockDataHashingStructure_Closure)
                 (const Common__BlockDataHashingStructure *message,
                  void *closure_data);
typedef void (*Common__OrdererAddresses_Closure)
                 (const Common__OrdererAddresses *message,
                  void *closure_data);
typedef void (*Common__Consortium_Closure)
                 (const Common__Consortium *message,
                  void *closure_data);
typedef void (*Common__Capabilities__CapabilitiesEntry_Closure)
                 (const Common__Capabilities__CapabilitiesEntry *message,
                  void *closure_data);
typedef void (*Common__Capabilities_Closure)
                 (const Common__Capabilities *message,
                  void *closure_data);
typedef void (*Common__Capability_Closure)
                 (const Common__Capability *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCMessageDescriptor common__hashing_algorithm__descriptor;
extern const ProtobufCMessageDescriptor common__block_data_hashing_structure__descriptor;
extern const ProtobufCMessageDescriptor common__orderer_addresses__descriptor;
extern const ProtobufCMessageDescriptor common__consortium__descriptor;
extern const ProtobufCMessageDescriptor common__capabilities__descriptor;
extern const ProtobufCMessageDescriptor common__capabilities__capabilities_entry__descriptor;
extern const ProtobufCMessageDescriptor common__capability__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_common_2fconfiguration_2eproto__INCLUDED */
