/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: peer/proposal.proto */

#ifndef PROTOBUF_C_peer_2fproposal_2eproto__INCLUDED
#define PROTOBUF_C_peer_2fproposal_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1000000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1002001 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif

#include "peer/chaincode.pb-c.h"
#include "peer/proposal_response.pb-c.h"
#include "token/expectations.pb-c.h"

typedef struct _Protos__SignedProposal Protos__SignedProposal;
typedef struct _Protos__Proposal Protos__Proposal;
typedef struct _Protos__ChaincodeHeaderExtension Protos__ChaincodeHeaderExtension;
typedef struct _Protos__ChaincodeProposalPayload Protos__ChaincodeProposalPayload;
typedef struct _Protos__ChaincodeProposalPayload__TransientMapEntry Protos__ChaincodeProposalPayload__TransientMapEntry;
typedef struct _Protos__ChaincodeAction Protos__ChaincodeAction;


/* --- enums --- */


/* --- messages --- */

/*
 * This structure is necessary to sign the proposal which contains the header
 * and the payload. Without this structure, we would have to concatenate the
 * header and the payload to verify the signature, which could be expensive
 * with large payload
 * When an endorser receives a SignedProposal message, it should verify the
 * signature over the proposal bytes. This verification requires the following
 * steps:
 * 1. Verification of the validity of the certificate that was used to produce
 *    the signature.  The certificate will be available once proposalBytes has
 *    been unmarshalled to a Proposal message, and Proposal.header has been
 *    unmarshalled to a Header message. While this unmarshalling-before-verifying
 *    might not be ideal, it is unavoidable because i) the signature needs to also
 *    protect the signing certificate; ii) it is desirable that Header is created
 *    once by the client and never changed (for the sake of accountability and
 *    non-repudiation). Note also that it is actually impossible to conclusively
 *    verify the validity of the certificate included in a Proposal, because the
 *    proposal needs to first be endorsed and ordered with respect to certificate
 *    expiration transactions. Still, it is useful to pre-filter expired
 *    certificates at this stage.
 * 2. Verification that the certificate is trusted (signed by a trusted CA) and
 *    that it is allowed to transact with us (with respect to some ACLs);
 * 3. Verification that the signature on proposalBytes is valid;
 * 4. Detect replay attacks;
 */
struct  _Protos__SignedProposal
{
  ProtobufCMessage base;
  /*
   * The bytes of Proposal
   */
  protobuf_c_boolean has_proposal_bytes;
  ProtobufCBinaryData proposal_bytes;
  /*
   * Signaure over proposalBytes; this signature is to be verified against
   * the creator identity contained in the header of the Proposal message
   * marshaled as proposalBytes
   */
  protobuf_c_boolean has_signature;
  ProtobufCBinaryData signature;
};
#define PROTOS__SIGNED_PROPOSAL__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&protos__signed_proposal__descriptor) \
    , 0,{0,NULL}, 0,{0,NULL} }


/*
 * A Proposal is sent to an endorser for endorsement.  The proposal contains:
 * 1. A header which should be unmarshaled to a Header message.  Note that
 *    Header is both the header of a Proposal and of a Transaction, in that i)
 *    both headers should be unmarshaled to this message; and ii) it is used to
 *    compute cryptographic hashes and signatures.  The header has fields common
 *    to all proposals/transactions.  In addition it has a type field for
 *    additional customization. An example of this is the ChaincodeHeaderExtension
 *    message used to extend the Header for type CHAINCODE.
 * 2. A payload whose type depends on the header's type field.
 * 3. An extension whose type depends on the header's type field.
 * Let us see an example. For type CHAINCODE (see the Header message),
 * we have the following:
 * 1. The header is a Header message whose extensions field is a
 *    ChaincodeHeaderExtension message.
 * 2. The payload is a ChaincodeProposalPayload message.
 * 3. The extension is a ChaincodeAction that might be used to ask the
 *    endorsers to endorse a specific ChaincodeAction, thus emulating the
 *    submitting peer model.
 */
struct  _Protos__Proposal
{
  ProtobufCMessage base;
  /*
   * The header of the proposal. It is the bytes of the Header
   */
  protobuf_c_boolean has_header;
  ProtobufCBinaryData header;
  /*
   * The payload of the proposal as defined by the type in the proposal
   * header.
   */
  protobuf_c_boolean has_payload;
  ProtobufCBinaryData payload;
  /*
   * Optional extensions to the proposal. Its content depends on the Header's
   * type field.  For the type CHAINCODE, it might be the bytes of a
   * ChaincodeAction message.
   */
  protobuf_c_boolean has_extension;
  ProtobufCBinaryData extension;
};
#define PROTOS__PROPOSAL__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&protos__proposal__descriptor) \
    , 0,{0,NULL}, 0,{0,NULL}, 0,{0,NULL} }


/*
 * ChaincodeHeaderExtension is the Header's extentions message to be used when
 * the Header's type is CHAINCODE.  This extensions is used to specify which
 * chaincode to invoke and what should appear on the ledger.
 */
struct  _Protos__ChaincodeHeaderExtension
{
  ProtobufCMessage base;
  /*
   * The PayloadVisibility field controls to what extent the Proposal's payload
   * (recall that for the type CHAINCODE, it is ChaincodeProposalPayload
   * message) field will be visible in the final transaction and in the ledger.
   * Ideally, it would be configurable, supporting at least 3 main visibility
   * modes:
   * 1. all bytes of the payload are visible;
   * 2. only a hash of the payload is visible;
   * 3. nothing is visible.
   * Notice that the visibility function may be potentially part of the ESCC.
   * In that case it overrides PayloadVisibility field.  Finally notice that
   * this field impacts the content of ProposalResponsePayload.proposalHash.
   */
  protobuf_c_boolean has_payload_visibility;
  ProtobufCBinaryData payload_visibility;
  /*
   * The ID of the chaincode to target.
   */
  Protos__ChaincodeID *chaincode_id;
};
#define PROTOS__CHAINCODE_HEADER_EXTENSION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&protos__chaincode_header_extension__descriptor) \
    , 0,{0,NULL}, NULL }


struct  _Protos__ChaincodeProposalPayload__TransientMapEntry
{
  ProtobufCMessage base;
  char *key;
  protobuf_c_boolean has_value;
  ProtobufCBinaryData value;
};
#define PROTOS__CHAINCODE_PROPOSAL_PAYLOAD__TRANSIENT_MAP_ENTRY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&protos__chaincode_proposal_payload__transient_map_entry__descriptor) \
    , NULL, 0,{0,NULL} }


/*
 * ChaincodeProposalPayload is the Proposal's payload message to be used when
 * the Header's type is CHAINCODE.  It contains the arguments for this
 * invocation.
 */
struct  _Protos__ChaincodeProposalPayload
{
  ProtobufCMessage base;
  /*
   * Input contains the arguments for this invocation. If this invocation
   * deploys a new chaincode, ESCC/VSCC are part of this field.
   * This is usually a marshaled ChaincodeInvocationSpec
   */
  protobuf_c_boolean has_input;
  ProtobufCBinaryData input;
  /*
   * TransientMap contains data (e.g. cryptographic material) that might be used
   * to implement some form of application-level confidentiality. The contents
   * of this field are supposed to always be omitted from the transaction and
   * excluded from the ledger.
   */
  size_t n_transientmap;
  Protos__ChaincodeProposalPayload__TransientMapEntry **transientmap;
};
#define PROTOS__CHAINCODE_PROPOSAL_PAYLOAD__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&protos__chaincode_proposal_payload__descriptor) \
    , 0,{0,NULL}, 0,NULL }


/*
 * ChaincodeAction contains the actions the events generated by the execution
 * of the chaincode.
 */
struct  _Protos__ChaincodeAction
{
  ProtobufCMessage base;
  /*
   * This field contains the read set and the write set produced by the
   * chaincode executing this invocation.
   */
  protobuf_c_boolean has_results;
  ProtobufCBinaryData results;
  /*
   * This field contains the events generated by the chaincode executing this
   * invocation.
   */
  protobuf_c_boolean has_events;
  ProtobufCBinaryData events;
  /*
   * This field contains the result of executing this invocation.
   */
  Protos__Response *response;
  /*
   * This field contains the ChaincodeID of executing this invocation. Endorser
   * will set it with the ChaincodeID called by endorser while simulating proposal.
   * Committer will validate the version matching with latest chaincode version.
   * Adding ChaincodeID to keep version opens up the possibility of multiple
   * ChaincodeAction per transaction.
   */
  Protos__ChaincodeID *chaincode_id;
  /*
   * This field contains the token expectation generated by the chaincode
   * executing this invocation
   */
  Protos__TokenExpectation *token_expectation;
};
#define PROTOS__CHAINCODE_ACTION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&protos__chaincode_action__descriptor) \
    , 0,{0,NULL}, 0,{0,NULL}, NULL, NULL, NULL }


/* Protos__SignedProposal methods */
void   protos__signed_proposal__init
                     (Protos__SignedProposal         *message);
size_t protos__signed_proposal__get_packed_size
                     (const Protos__SignedProposal   *message);
size_t protos__signed_proposal__pack
                     (const Protos__SignedProposal   *message,
                      uint8_t             *out);
size_t protos__signed_proposal__pack_to_buffer
                     (const Protos__SignedProposal   *message,
                      ProtobufCBuffer     *buffer);
Protos__SignedProposal *
       protos__signed_proposal__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   protos__signed_proposal__free_unpacked
                     (Protos__SignedProposal *message,
                      ProtobufCAllocator *allocator);
/* Protos__Proposal methods */
void   protos__proposal__init
                     (Protos__Proposal         *message);
size_t protos__proposal__get_packed_size
                     (const Protos__Proposal   *message);
size_t protos__proposal__pack
                     (const Protos__Proposal   *message,
                      uint8_t             *out);
size_t protos__proposal__pack_to_buffer
                     (const Protos__Proposal   *message,
                      ProtobufCBuffer     *buffer);
Protos__Proposal *
       protos__proposal__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   protos__proposal__free_unpacked
                     (Protos__Proposal *message,
                      ProtobufCAllocator *allocator);
/* Protos__ChaincodeHeaderExtension methods */
void   protos__chaincode_header_extension__init
                     (Protos__ChaincodeHeaderExtension         *message);
size_t protos__chaincode_header_extension__get_packed_size
                     (const Protos__ChaincodeHeaderExtension   *message);
size_t protos__chaincode_header_extension__pack
                     (const Protos__ChaincodeHeaderExtension   *message,
                      uint8_t             *out);
size_t protos__chaincode_header_extension__pack_to_buffer
                     (const Protos__ChaincodeHeaderExtension   *message,
                      ProtobufCBuffer     *buffer);
Protos__ChaincodeHeaderExtension *
       protos__chaincode_header_extension__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   protos__chaincode_header_extension__free_unpacked
                     (Protos__ChaincodeHeaderExtension *message,
                      ProtobufCAllocator *allocator);
/* Protos__ChaincodeProposalPayload__TransientMapEntry methods */
void   protos__chaincode_proposal_payload__transient_map_entry__init
                     (Protos__ChaincodeProposalPayload__TransientMapEntry         *message);
/* Protos__ChaincodeProposalPayload methods */
void   protos__chaincode_proposal_payload__init
                     (Protos__ChaincodeProposalPayload         *message);
size_t protos__chaincode_proposal_payload__get_packed_size
                     (const Protos__ChaincodeProposalPayload   *message);
size_t protos__chaincode_proposal_payload__pack
                     (const Protos__ChaincodeProposalPayload   *message,
                      uint8_t             *out);
size_t protos__chaincode_proposal_payload__pack_to_buffer
                     (const Protos__ChaincodeProposalPayload   *message,
                      ProtobufCBuffer     *buffer);
Protos__ChaincodeProposalPayload *
       protos__chaincode_proposal_payload__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   protos__chaincode_proposal_payload__free_unpacked
                     (Protos__ChaincodeProposalPayload *message,
                      ProtobufCAllocator *allocator);
/* Protos__ChaincodeAction methods */
void   protos__chaincode_action__init
                     (Protos__ChaincodeAction         *message);
size_t protos__chaincode_action__get_packed_size
                     (const Protos__ChaincodeAction   *message);
size_t protos__chaincode_action__pack
                     (const Protos__ChaincodeAction   *message,
                      uint8_t             *out);
size_t protos__chaincode_action__pack_to_buffer
                     (const Protos__ChaincodeAction   *message,
                      ProtobufCBuffer     *buffer);
Protos__ChaincodeAction *
       protos__chaincode_action__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   protos__chaincode_action__free_unpacked
                     (Protos__ChaincodeAction *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*Protos__SignedProposal_Closure)
                 (const Protos__SignedProposal *message,
                  void *closure_data);
typedef void (*Protos__Proposal_Closure)
                 (const Protos__Proposal *message,
                  void *closure_data);
typedef void (*Protos__ChaincodeHeaderExtension_Closure)
                 (const Protos__ChaincodeHeaderExtension *message,
                  void *closure_data);
typedef void (*Protos__ChaincodeProposalPayload__TransientMapEntry_Closure)
                 (const Protos__ChaincodeProposalPayload__TransientMapEntry *message,
                  void *closure_data);
typedef void (*Protos__ChaincodeProposalPayload_Closure)
                 (const Protos__ChaincodeProposalPayload *message,
                  void *closure_data);
typedef void (*Protos__ChaincodeAction_Closure)
                 (const Protos__ChaincodeAction *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCMessageDescriptor protos__signed_proposal__descriptor;
extern const ProtobufCMessageDescriptor protos__proposal__descriptor;
extern const ProtobufCMessageDescriptor protos__chaincode_header_extension__descriptor;
extern const ProtobufCMessageDescriptor protos__chaincode_proposal_payload__descriptor;
extern const ProtobufCMessageDescriptor protos__chaincode_proposal_payload__transient_map_entry__descriptor;
extern const ProtobufCMessageDescriptor protos__chaincode_action__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_peer_2fproposal_2eproto__INCLUDED */
